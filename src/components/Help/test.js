"accesstoken._exportIds": "Select the Exports that this token should provide access to.",,
 {"accesstoken._connectionIds": "Select the Connections that this token should provide access to.",
"accesstoken._importIds: "Select the Imports that this token should provide access to.",
"accesstoken.autoPurgeAt": "Select the time after which the token should be automatically purged from the system.",
"accesstoken.description": "Describe how your token is being used and be sure to mention exactly where your token is being stored externally.",
"accesstoken.name": "Name your token so that you can easily reference it from other parts of the application",
"accesstoken.scope": "Scope is used to define access permissions for your token.↵↵<ul><li><b>Full Access</b> - Full access tokens have unlimited permissions to your integrator.io account. Please be very careful provisioning full access tokens!</li>↵↵<li><b>Custom</b> - Custom scope tokens can be created with only minimal permissions to specific resources in your integrator.io account, and they can only be used to invoke very specific integrator.io APIs (i.e. only the APIs required to import or export data from external applications).</li></ul>",
"ashare.accessLevel.allIntegrations": "List of integrations available in your account to which you can invite users to manage and/or monitor.",
"ashare.accessLevel.integrationsToManage": "The invited user will have permissions to manage the integrations listed here.",
"ashare.accessLevel.integrationsToMonitor": "The invited user will have permissions to monitor the integrations listed here, but they will not have permissions to make any changes to them. They will however be able to run the flows within the integrations.",
"ashare.email": "Enter the email of the user you would like to invite to manage and/or monitor selected integrations.",
"asynchelper.http.response.resourcePath": "This field appears if Same As Status Export checkbox is disabled. Specify the path for obtaining other feed info resources. This data is passed to Status and Result exports for evaluating handlebars.↵ For example, <i>/SubmitFeedResponse/SubmitFeedResult/FeedSubmissionInfo</i>.",
"asynchelper.rules": "This field is optional. You can use it when the response is other JSON. For example, if your target application is Amazon, the response data received will be in XML format that you can convert to JSON using Transform Rules for Submit Response. For more information, refer to <a href="https://celigosuccess.zendesk.com/hc/en-us/articles/115002669511-Transformation-Rules-Guide">Transform Rules Guide</a>",
"connection.amazonmws.authToken": "The MWS authorization token.",
"connection.amazonmws.marketplaceId": "Please specify the Amazon MWS 'MarketplaceId' for this connection. This value is required for specific Amzaon MWS requests to succeed. Please note that you must be registered to sell in the Amazon MWS 'MarketplaceId' selected, else your Amazon MWS calls will fail.",
"connection.as2.partnerStationInfo.requireAsynchronousMDNs": "Check this box if your trading partner requires MDNs to be sent asynchronously. By default, integrator.io is configured to send MDNs synchronously.",
"connection.as2.userStationInfo.as2URL": "This is the URL to which your trading partners will send AS2 documents. Note that the same URL is used for all integrator.io users, which is why the above AS2 identifier must be unique. It is not editable but is provided here so that you can communicate it to your trading partners.",
"connection.as2.userStationInfo.ipAddresses": "These are the IP addresses of the various servers that comprise integrator.io. These should be shared with your trading partners if the trading partner has a firewall that needs to be configured to allow inbound AS2 traffic from integrator.io",
"connection.as2.userStationInfo.requireAsynchronousMDNs": "Celigo's integrator.io is configured to expect synchronous MDNs from trading partners. Since we do not require asynchronous MDNs, there is no need to set a specific URL to receive asynchronous MDNs. This field is not editable but is provided so that you can easily share this setting with your trading partners.",
"connection.as2.userStationInfo.requireMDNsFromPartners": "Celigo's integrator.io is configured to require MDNs from partners. This field is not editable but is provided so that you can easily share this setting with your trading partners.",
"connection.connMode": "Select Cloud if you are connecting to an application on the cloud and is publicly accessible. For example, Salesforce, NetSuite. Select On-Premise if you are connecting to a server that is publicly inaccessible and has integrator.io Agent installed on it. For example, Production AWS VPC, MySQL server."
"connection.configureApiRateLimits": "By default the HTTP adaptor will treat all HTTP responses with status code 429 as being rate-limited and then look for a “retry-after” header to determine when our platform can retry the request. If the service you are connecting to respects these HTTP specifications, then you do not need any additional configuration. If however your service implements a custom rate-limit response structure, use these options to tell our platform how to identify and respond to a rate-limited response.",
"connection.ftpType": "The file transfer protocol using which you want to establish the FTP connection.↵The following protocols are available:↵<bold>FTP:</bold> Select FTP if the server that you are connecting to requires an FTP protocol.↵SFTP: Select SFTP if the server that you are connecting to requires an SFTP protocol.↵FTPS: Select FTPS if the sever that you are connecting to requires an FTPS protocol."
"connection.enableDebugging": "Set this flag if you want to establish the connection in debug mode."
"connection.http.auth.oauth.applicationType": "These are the OAuth 2.0 providers currently supported by integrator.io. Please contact support if you need an application that is not currently listed here, and it is also worth checking with the application provider to see if they have any other forms of API authentication available. For example, Shopify supports both OAuth 2.0 and Basic Auth (i.e. username and password). Keep in mind too that once a new OAuth 2.0 provider is supported by integrator.io you will likely be able to choose that application directly in the 'Connection Type' field (vs connecting at the technology level via HTTP or REST)."
"connection.http._iClientId": "iClient lets you configure your developer access and secret keys for your marketplace region."
"connection.marketplaceRegion": "Please specify the Amazon MWS Region for this connection. Please note that you must be registered to sell in the Amazon MWS Region selected, else your Amazon MWS calls will fail."
"connection.httpHeaders": "Click this button to specify any custom HTTP header name and value pairs which will be added to all HTTP requests. Note that in most cases our platform will auto-populate common headers such as "content-type" (based of the media type of the request), or the "Authorize" header (used if your application authenticates using tokens in the header). Unless your HTTP request fails or does not return expected results, there is no need to use this feature. In some rare cases, it may be necessary to add other application specific headers that the integrator.io platform does not manage. An example of this would be adding an "x-clientId" or any other application specific header. These would be documented in the API guide of the Application you are integrating with."
"connection.netsuite.linkSuiteScriptIntegrator": "Prior to integrator.io, NetSuite integrations built by Celigo ran directly inside your NetSuite account via a managed bundle. If you are still running any of these older integrations this field must be used to link integrator.io to your NetSuite account. Celigo's older UI that ran directly inside NetSuite has been deprecated, and users are required to use integrator.io going forward to manage and monitor all integrations."
"connection.netsuite.authType": "Please choose 'Basic' to use your NetSuite email and password for this connection, or choose 'Token' to use NetSuite's new token based authentication. Token based auth is slightly more complicated to enable, but it is much more secure than email and password, and your tokens will never expire. It is also common for users to start out with basic auth and then switch to token based auth when an integration is ready for production.  You can switch back and forth between basic and token based auth at any time. Please contact NetSuite support if you need help creating Access Tokens inside NetSuite."
"connection.rest.applicationType": "These are the OAuth 2.0 providers currently supported by integrator.io. Please contact support if you need an application that is not currently listed here, and it is also worth checking with the application provider to see if they have any other forms of API authentication available. For example, Shopify supports both OAuth 2.0 and Basic Auth (i.e. username and password). Keep in mind too that once a new OAuth 2.0 provider is supported by integrator.io you will likely be able to choose that application directly in the 'Connection Type' field (vs connecting at the technology level via HTTP or REST)."
"connection.rdbms.useSSL": "Please check this field if you want to establish a secure connection to the database. This ensures that data in transit is encrypted."
"connection.rest.bearerToken": "The 3dcart merchant's token."
"connection.rest.authType": "integrator.io supports the following authentication types:↵↵<b>Basic:</b> Select Basic if your service implements the HTTP basic authentication strategy. This authentication method adds a Base64 encoded username and password values in the 'authentication' HTTP request header.↵↵<b>Cookie</b>: Select Cookie if your service relies on session-based authentication. Session based authentication is typically implemented by including a unique cookie into the HTTP request header. By selecting this option, the platform will automatically create and insert this cookie into every HTTP request it sends to your application. ↵↵<b>Custom:</b> Select Custom for all other types. If you select the Custom authentication method, integrator.io will not perform any special authentication. It is up to the user to configure the HTTP request fields (method, relativeUri, headers, and body) of the import and export models to include {{placeholders}} for any authentication related values. These values can be stored in Encrypted and Unencrypted fields of this connection.↵↵<b>Token:</b>  Select Token if your service relies on token-based authentication. The token may exist in the header, URL, or body of the HTTP request. This method also supports refreshing tokens if the service being called supports it.↵↵<b>OAuth 2.0:</b> Select this value if your application supports the OAuth 2.0 authentication."
"connection.rest.pingBody": "This field is typically used in for HTTP requests not using the GET method. The value of this field becomes the HTTP body that is sent to the API endpoint. The format of the body is dependent on the API being used. It could be URLl-encoded, JSON, or XML data. In either case, the metadata contained in this body will provide the API with the information needed to fulfill your ping request. Note that this field can contain {{{placeholders}}} that are populated from a model comprising of a connection and an export object. For example, if the export request body requires an authentication token to be embedded, you can use the placeholder {{connection.http.auth.token.token}}."
"connection.rest.encrypted": "Use this JSON field to store all the security sensitive fields needed by your imports and exportsto access the application being integrated. For example: {'password': 'ayTb53Img!do'} or {'token': 'x7ygd4njlwerf63nhg'}. Please note that in addition to AES 256 encryption there are multiple layers of protection in place to keep your data safe."
"connection.rest.storeName": "Go to your Shopify store and you can find out the store name in the browser URL. For example - if your Shopify store URL is 'https://demo-store.myshopify.com/', then provide 'demo-store' as the store name."
"connection.rest.pingMethod": "The HTTP method (GET/PUT/POST/HEAD) to use when making the ping request."
"connection.rest.unencrypted": "Use this JSON field to store all the security insensitive fields needed by your imports and exports to access the application being integrated. For example: {'email':'my_email@company.com', 'accountId': '5765432', 'role': 'admin'}"
"connection.rest.threedcartSecureUrl": "3dcart merchant's Secure URL."
"connection.salesforce.sandbox": "Select Production or Sandbox from this field. You can then click on Save & Authorize that opens a Salesforce window where you can enter your Salesforce account credentials to connect to Salesforce."
"connection.salesforce.oauth2FlowType": "The Force.com platform implements the OAuth 2.0 Authorization Framework, so users can authorize applications to access Force.com resources on their behalf without revealing their passwords or other credentials to those applications. You can select one of the following authorization flows for authentication. ↵ ↵ <b>Refresh Token Flow:</b> This flow tends to be used for web applications where server-side code needs to interact with Force.com APIs on the user's behalf. ↵ ↵ <b>JWT Bearer Token Flow:</b> The main use case of the JWT Bearer Token Flow is server-to-server API integration. This flow uses a certificate to sign the JWT request and doesn’t require explicit user interaction."
"connection.scope": "OAuth 2.0 scopes provide a way to limit the amount of access that is granted to an access token. For example, an access token issued to a client app may be granted READ and WRITE access to protected resources, or just READ access."
"connection.salesforce.username": "Enter the username for your Salesforce Account for 'JWT Bearer Token' authentication."
"connection.shopify.rest.basicAuth.username": "Login to your Shopify store and navigate to 'Apps' section. Click on the respective private app and the API key can be found next to the 'Authentication' section."
"connection.shopify.rest.basicAuth.password": "Login to your Shopify store and navigate to 'Apps' section. Click on the respective private app and the password can be found next to the 'Authentication' section."
"connection.threedcart.rest.bearerToken": "The 3dcart merchant's token."
"connection.shopify.rest.storeName": "Go to your Shopify store and you can find out the store name in the browser URL. For example - if your Shopify store URL is 'https://demo-store.myshopify.com/', then provide 'demo-store' as the store name."
"connection.threedcart.rest.threedcartSecureUrl": "3dcart merchant's Secure URL."
"connection.threedcart.rest.encrypted.PrivateKey": "Your application's private key."
"connection.useSFTP": ""
"connection.timeFrame": ""
"distributed.orderBy": "Use this field to specify how you would like to order the related list records. Ex: Use `CreatedDate` to order the records by date created. The default order is `Ascending order`. To change it to use descending order using the order by field as `CreatedDate DESC`."
"distributed.filter": "Use this field to filter out any reference list by entering the "where" clause of SOQL query. This expression will be added as a part of the SOQL query in the where clause while fetching the childSObjectType. If no filter is added, IO will send all the child SObjects in the export data. Ex: If you would like to only export Contacts whose LastName has "Bond" in it, set the expression as "LastName=`Bond` "."
"distributed.sObjectType": "Use this field to specify the additional referencelist (child sObjects of parent sObject) that you would like to add to the export data. Ex: Contact is a childSObjectType for the parentSObject type Account."
"distributed.referencedFields": "Use this setting to add additional fields on the childSObject to the export data defined as lookup fields on Salesforce. Ex: If Contact is set as the childSObjectType, this setting allows users to pull data from the reference fields (such as Created By, Account Name) on the Contact sObject."
"export.batchSize": "NetSuite's search APIs will by default return up to 1000 records every time you request a new page of results. This is problematic if you need to execute a SuiteScript based hook on the records before they are exported (in which case you will likely run out of SuiteScript points or hit NetSuite instruction count limits), or if the individual records you are exporting are very large such that the sum of all 1000 records exceeds 5 MB (which is also not allowed). For either situation, this field can easily be used to tell integrator.io to break down the default 1000 record batches into smaller batches where you define the ideal size."
"export._applicationId": "This field lists all applications and technology adaptors that integrator.io supports for exporting or importing the data. For less technical users, application adaptors, such as NetSuite or Salesforce are the easiest to use, whereas technology adaptors, such as the REST API adaptor requires a more technical understanding of the applications being integrated. However, once you learn how to use a specific technology adaptor, you will be able to integrate a multitude of different applications without having to wait for integrator.io to expose specific application adaptors.↵If you are unable to find a matching application or a technology adaptor, the only other connectivity option is to use the integrator.io extension framework to develop a custom Wrapper. For more information on Wrappers and to learn more about integrator.io's developer extension framework, contact Celigo Support."
"export.csvFile": "Please select a file from your local computer that you would like to import. The maximum file size allowed is currently 100 MB. If you need to import anything larger than this please log a support ticket, or as a work around you can break your larger files into separate smaller ones."
"export.configureAsyncHelper": "If data is exported asynchronously, check this field to select the Async Helper configuration to be used."
"export.executionType": ""
"export.ediFormat": "Please select the file format that most closely matches your needs. If the exact format is not found, select the closest template. You will have an opportunity to modify the rules within this template by using the “File Definition Editor” below."
"export.file.extractFile": "If the files you are exporting are in a compressed format then please set this field to true."
"export.file.csv.hasMultipleRowsPerRecord": "Select this checkbox, if your CSV or XLSX contains multiple records that can be grouped together. For example, line items of a sales order.↵Note: This is applicable only for CSV and XLSX files."
"export.filedefinitionRules": "File Definition Rules are used by our platform to understand how to extract data from your EDI file. The result of evaluating these rules against your EDI files are JSON records, which can then be used anywhere in your integration. ↵ Once you have selected a template that most closely matches your needs, this editor can be used to modify (if needed) the parsing rules in the stock template to your specific needs. If no template is available that meets your needs, this editor can also be used to write your own “file definition” from scratch. ↵ Within the editor, the Available Resources pane holds all the raw EDI file export. The File Definition Rules pane describes how the available resources should be converted to JSON. The Generated Export pane shows the generated JSON which the platform will work with following the export, based on the defined rules."
"export.file.fileDefinition.resourcePath": "In some cases, you may not require all the data within the parsed EDI file. You can use this optional field to select where the data you are interested in is located within the JSON object generated by your File Definition Rules. The format of this field is a JSON path. An example would be, ’N1.N3’."
"export.hookType": "Please select 'Script' if you want to use the native integrator.io JavaScript runtime engine (where all your code is managed and executed by integrator.io), or choose 'Stack' if you prefer to host your code outside integrator.io (either on your own servers, or on AWS Lambda)."
"export.fixedWidthFormat": "Please select the file format that most closely matches your needs. If the exact format is not found, select the closest template. You will have an opportunity to modify the rules within this template by using the “File Definition Editor” below."
"export.http._asyncHelperId": "Select an existing Async Helper configuration or create a new one to be used for async response processing."
"export.http-headers": "Click this button to specify any custom HTTP header name and value pairs which will be added to all HTTP requests. Note that in most cases our platform will auto-populate common headers such as "content-type" (based of the media type of the request), or the "Authorize" header (used if your application authenticates using tokens in the header). Unless your HTTP request fails or does not return expected results, there is no need to use this feature. In some rare cases, it may be necessary to add other application specific headers that the integrator.io platform does not manage. An example of this would be adding an "x-clientId" or any other application specific header. These would be documented in the API guide of the Application you are integrating with."
"export.netsuite.apiType": ""
"export.invoke-url": "It is possible to invoke this export at any time by using this URL in a POST request to our API. You can use any HTTP client (like <a target="blank" href="https://www.getpostman.com/">Postman</a>) to invoke this export. Set the HTTP method in your client app to POST, and use the url below to uniquely target this export. You will also need to set the "content-type" header of your request to application/json and the "authorize" header to "Bearer [ your API token ]". Finally, if your export contains {{ placeholders }} within its fields, you can populate these by including values for these placeholders as a JSON object in the POST body of the HTTP request."
"export.netsuite.executionType": "This is a required field to specify the exact execution type values for which a record should be exported in real-time.  It is very common for a real-time export to include 'Create' to export brand new records when they are first submitted to NetSuite, and then also to include both 'Edit' and 'Inline Edit' to export records that have been changed.  Some of the other values available in this field are a bit more advanced, and please check the NetSuite help guides (or contact NetSuite support) for more info on what the different execution types mean. To provide at least one example for one of the more advanced options, you might want to enable a real-time export on the Sales Order record type in NetSuite, but you ONLY want the sales order to be exported when an approver clicks on the Approve button for the order (or via a mass approval action).   A possible usecase for this export would be to route a simple message into a Slack or HipChat type application to let someone (or a team of people) know via chat that an order has been approved."
"export.netsuite.executionContext": "This is a required field to specify the exact execution context values for which a record should be exported in real-time.  For example, it is very common for a real-time export to run only for 'User Interface' and 'Web Store' changes.  These values both represent actual end users manually submitting changes to NetSuite (like a user editing and saving a customer record in the browser, or a shopper submitting an order via the web store), and these manual data changes are normally small and also important to propagate quickly to other applications (i.e. new web orders probably need to get sent to the shipping API asap).  Execution context values like 'CSV Import' are risky to enable because (1) you will slow down your mass update due to the overhead of sending data to an external system one record at a time, and (2) you may inadvertently flood your integration with way too many individual records that don't need to be synced right away (where a scheduled data flow would have been a better fit)."
"export.netsuite.hooks.preSend": ""
"export.netsuite.forceReload": "When a record is saved in NetSuite there are certain fields that are not available until after the save completes, and the only way to export those fields in real-time is to reload the record again from the NetSuite database.  One example of this is the Line ID field on many of NetSuite's transaction record types (i.e. sales order, transfer order, etc...).  When a transaction record is first created, or when new line items are added to an existing transaction record, the Line ID values are not immediately available, and it is required to re-load the record again from the NetSuite database to export the Line ID values.  Please note that this extra load is relatively expensive too (for NetSuite) and will slow down the real-time export, so if you do not need one of these special fields then please avoid using this reload setting.  Unfortunately also, there is no master list of all the fields that require a reload (at least not presently), so trial and error might be needed if a field is not being exported as expected."
"export.netsuite.recordType": "Use this field to specify which NetSuite record type you want to export. You can choose any standard record type (i.e. customer, sales order, journal entry) or any custom record type that has been defined in your NetSuite account. Please note that this list of record types is dependent on the permissions associated with the connection selected above. Also, if you add any new custom record types to your NetSuite account, or if there are any changes to the permissions associated with the connection selected above, you can use the refresh icon (next to this field) to regenerate the list."
"export.netsuite.qualifier": "Use this field to further refine which records you would like to export based on fields and their values (i.e. by looking at the record before it is exported and evaluating simple conditional expressions to decide if the record should be exported or discarded).  For example, if you are exporting customers you can use this field to only export customers that belong to a specific subsidiary, or if you are exporting sales orders you can use this field to only export sales orders that exceed a certain amount.  You can also perform more complex expressions using AND and OR.  For example, if you are exporting items you can use this field to only export items belonging to a specific vendor AND only items that are displayed in your web store."
"export.netsuite.restlet.searchType": "NetSuite Saved Searches are an incredibly powerful and super easy way to define the exact data that you want to extract out of NetSuite.  By default, integrator.io can see all the public Saved Searches in your NetSuite account, and we display them all below so that you can quickly select the search data that you want to export.  If you want to export the data from a private Saved Search that works too, but please specify that here so that we know to prompt you for one extra field needed to access the private Saved Search (i.e. because we cannot by default see the private searches in your account we need you to tell us one more detail).  For private Saved Searches also, please make sure that the credentials associated with the connection record set above have access to the search results data in NetSuite."
"export.netsuite.restlet.searchInternalId": "To use a private NetSuite Saved Search please tell us the Internal Id of the Saved Search here (should be a numeric value) .  One way to obtain this value is to navigate to the Saved Search in the NetSuite UI and then in the browser URL you should see a numeric searchId field (i.e. searchid=123456 and then just use the numeric part 123456).  Another way to obtain this value is by editing the Saved Search and then in the 'ID' field there should be a numeric value that you can extract (i.e. customsearch123456 and then just use the numeric part 123456).  Please contact NetSuite support if you need more guidance finding your Saved Search Internal Ids."
"export.netsuite.searches.savedSearchId": ""
"export.netsuite.searches.recordType": ""
"export.oneToMany": "There are advanced use cases where a parent record is being passed around in a flow, but you actually need to process child records contained within the parent record context. For example, if you are exporting Sales Order records out of NetSuite but you want to enhance each line item in the Sales Order with addition information stored in NetSuite (i.e. by running a dynamic search for each line item), then you will need to use this option."
"export.netsuite.sublists": "In order to keep the time it takes to save a record in NetSuite lightening fast, the default behavior for a real-time export is to ONLY include body level fields (like name, phone and email for a customer record).  If you do need to export sublist data (like the addresses for a customer,  or the line items in a sales order, or basically any data that is displayed in the NetSuite UI as a list) then you need to explicitly specify that here in this field.  Also, when including sublist data please keep in mind that each sublist typically requires an extra query to NetSuite to get the extra data, and while each individual query is relatively fast, if you are exporting lots of different sublists it can slow down the time it takes so save a record in NetSuite (i.e. when you click save for a record that has a real-time export deployed that also includes lots of different sublists it might take a little longer for the save to complete due to the extra queries)."
"export.pathToMany": "If the parent record is represented by a JSON object, then this field should be used to specify the JSON path of the child records. If the parent record is represented by a JSON array (where each entry in the array is a child record), then this field does not need to be set. If you are unsure how parent records are being represented in your flow then please view the 'Sample Data' field for the 'Export' resource that is generating the data. Following are two examples also to hopefully help clarify how data can be represented differently depending on the export context. Example 1: If you are exporting Sales Orders out of NetSuite in real-time then NetSuite sends integrator.io a JSON object for each Sales Order, and if you want to process the line items in that Sales Order then you need to specify the JSON path for the line items field. There is no way to tell NetSuite to send an array for real-time data. Example 2: But, if you are exporting Sales Orders out of NetSuite via a scheduled flow, then in this case NetSuite represents each order via an array where each entry in the array represents a line item in the order. There is no way to tell NetSuite to give you an object for batch data."
"export.overrideDataURITemplate": "For applications like NetSuite and Salesforce, integrator.io will by default try to generate links for any records that fail to export and then display those links in your job dashboard.  If you prefer to define your own custom links then please use this handlebars field to override the default functionality.  For example, if you are exporting sales orders but instead want the errors to link to customers, you could use the following.  "https://system.na1.netsuite.com/app/common/entity/custjob?id={{{entity}}}""
"export.relatedLists": "Use this setting to add additional fields from the related/sublist sObject to the export data defined on the sObject on Salesforce. Ex: Contact sObject is a sublist sObject for an Account. This setting allows users to pull data from sublist fields such as Name, Email and Department from all Contact records related to an Account record. Users can also use filters to only pull filtered Contacts belonging to a specific Department."
"export.referencedFields": "Use this setting to add additional fields to the export data defined as lookup fields on the sObject on Salesforce. Ex: Account is a lookup field on Opportunity. This setting allows users to pull data from the reference fields (such as Name, AccountNumber) on the Account sObject."
"export.s3.bucket": "The Amazon S3 folder path. For example, Mysite/Orders."
"export.requiredTrigger": "When you select an sObject type in the SObject Type field, an Apex trigger code is generated in this field. This code is required per sObject type to facilitate real-time data exports. You have to copy this code using the Copy icon and paste it in the Salesforce page in your account, the link for which appears just below this field."
"export.searchCriteria": "This field can be used to specify any additional search criteria for the saved search that you want to execute for this flow. These will be added to the existing saved search criteria before records are exported out of NetSuite."
"export.salesforce.sObjectType": "Use this field to specify which Salesforce sObject type you want to export.  You can choose any standard sObject type (i.e. account, opportunity, contact) or any custom sObject type as long as the sObject type supports Salesforce triggers. Please note that this list of sObject types is also dependent on the permissions associated with the connection selected above. Also, if you add any new custom sObject types to your Salesforce account, or if there are any changes to the permissions associated with the connection selected above, you can use the refresh icon (next to this field) to regenerate the list."
"export.webhook.url": "If a URL has not already been generated, please use the 'Click To Generate' link below to generate a public URL for this webhook export, and then you will need to share this generated URL with the webhook provider through that provider's UI or API.  Saying this another way, each webhook provider (like GitHub, Shopify, etc...) will support a mechanism to configure the URL where you want the webhook data sent, and all you need to do to send data to integrator.io is provide them with this generated URL here.  Regarding security, please note that the data sent to this URL will always be secured via some sort of data verification (i.e. typically an HMAC or a token in the payload), along with SSL."
"export.skipRetries": "Select this checkbox if you do not want integrator.io to retry importing failed records."
"flow.endTime": "This field lets you control the last scheduled execution of your flow (i.e. your integration flow will not be scheduled after this time)."
"flow.daysToRunOn": "This field lets you configure the specific day(s) you would like this integration flow to run on."
"flow.startTime": "This field lets you control the first execution time of your flow (i.e. your integration flow will not run before this time), and then subsequent execution times are determined by the 'Frequency' and 'End Time' values set."
"flow.frequency": "This field dictates how often your integration flow is run. Please log a support ticket if there is a specific preset frequency that you would like to see added to this list."
"import._applicationId": "This field lists all applications and technology adaptors that integrator.io supports for exporting or importing the data. For less technical users, application adaptors, such as NetSuite or Salesforce are the easiest to use, whereas technology adaptors, such as the REST API adaptor requires a more technical understanding of the applications being integrated. However, once you learn how to use a specific technology adaptor, you will be able to integrate a multitude of different applications without having to wait for integrator.io to expose specific application adaptors.↵If you are unable to find a matching application or a technology adaptor, the only other connectivity option is to use the integrator.io extension framework to develop a custom Wrapper. For more information on Wrappers and to learn more about integrator.io's developer extension framework, contact Celigo Support."
"flow.type": "Please select 'Use Presets' if you would like to use one of the more popular frequency options, and then the UI will guide you through the setup for each. If you need something more custom then please select 'Use Cron Expression', and then the UI will display a simple cron builder to help you define a custom frequency."
"import.configureAsyncHelper": "If data is imported asynchronously, check this field to select the Async Helper configuration to be used."
"import.as2Headers": "Click this button to specify any custom HTTP header name and value pairs that will be added to all outgoing AS2 messages. Note that in most cases you will not need to populate any headers here, but if your trading partner's AS2 endpoint requires certain headers to be present (even if not required by the AS2 specification), this feature will allow that."
"import.ediFormat": "Please select the file format that most closely matches your needs. If the exact format is not found, select the closest template. You will have an opportunity to modify the rules within this template by using the “File Definition Editor” below."
"import.csvFile": "Please provide a sample file that this import would need to process.  We will use the sample file to auto set various fields (where possible), and also to help you map data in a subsequent step.  The sample file that you provide does not need to be overly large, but it should contain all the fields that you want to work with, and also be in the same format that the import will need to generate when running in a production capacity."
"import.expression": "This field represents your complete handlebar expression. You have the freedom to manually enter an expression, or use the function and field drop-downs above to help construct it."
"import.etailImportFieldMappingSettings": "The type of field mapping that you want to perform. For more information refer to, the <a href="https://celigosuccess.zendesk.com/hc/en-us/sections/205928707-Field-Mapping-options-in-integrator-io" target="_blank"/> Field Reference Guide.</a>"
"import.field": "This dropdown lists all the available fields from your export record that can be used in your expression. Either by themselves, or as argument value for any selected helper methods."
"import.failFields": "<b>Use Empty String as Default Value:</b> Please select this field if you want to use ‘’(i.e. the empty string) as the default lookup value. This value will be used if your lookup does not find anything. ↵↵<b>Use Null as Default Value:</b> Please select this field if you want to use ‘null’ as the default lookup value. This value will be used if your lookup does not find anything. ↵↵<b>Use Custom Default Value:</b> This holds the default value to be set for the extract field."
"import.filedefinitionRules": "File Definition Rules are used by our platform to generate your EDI file. Once you have selected a template that most closely matches your needs, this editor is used at a minimum, to modify those rules to indicate where to find your data values. If you did not find an exact template match, this editor can also be used to make changes to an existing template or even write your own from scratch. ↵ Within the editor, the “Available Resources” pane holds all the data that you can reference within the file definition rules. The “File Definition Rules” pane holds the instructions in JSON format that will be used to generate your EDI file. The Generated Import field shows, in real-time, the generated output based on your defined rules."
"import.file.compressFile": "Set this field to true if you would like to compress files before they are posted to the import application."
"import.ftp.useUploadInProgressTempFile": "Some FTP sites require that a file use a temporary file name pattern while an upload is in progress, and then after an upload is complete that a file be renamed to officially let the FTP site know that no more data is expected, and that the file can safely be processed by another application."
"import.fixedWidthFormat": "Please select the file format that most closely matches your needs. If the exact format is not found, select the closest template. You will have an opportunity to modify the rules within this template by using the “File Definition Editor” below."
"import.hooks.postAggregate.scriptFunction": "The name of the postAggregate hook function (in your script) that you want to invoke."
"import.function": "This drop-down has all the available helper methods that let you transform your field values. Once you make a selection, the function and placeholder values will be added to the expression text box below. You can then make any necessary changes by editing the complete expression.For a complete list and extended help of all helper methods, please see this article: <a target="blank" href="https://celigosuccess.zendesk.com/hc/en-us/articles/115004695128-Handlebar-Helpers-Reference-Guide">Handlebar Helper Guide</a>"
"import.hooks.postSubmit.scriptFunction": "The name of the postSubmit hook function (in your script) that you want to invoke."
"import.hooks.postMap.scriptFunction": "The name of the postMap hook function (in your script) that you want to invoke."
"import.http-headers": "Click this button to specify any custom HTTP header name and value pairs which will be added to all HTTP requests. Note that in most cases our platform will auto-populate common headers such as "content-type" (based of the media type of the request), or the "Authorize" header (used if your application authenticates using tokens in the header). Unless your HTTP request fails or does not return expected results, there is no need to use this feature. In some rare cases, it may be necessary to add other application specific headers that the integrator.io platform does not manage. An example of this would be adding an "x-clientId" or any other application specific header. These would be documented in the API guide of the Application you are integrating with."
"import.hooks.preMap.scriptFunction": "The name of the preMap hook function (in your script) that you want to invoke."
"import.invoke-url": "It is possible to invoke this import at any time by using this URL in a POST request to our API. You can use any HTTP client (like <a target="blank" href="https://www.getpostman.com/">Postman</a>) to invoke this import. Set the HTTP method in your client app to POST, and use the url below to uniquely target this import. You will also need to set the "content-type" header of your request to application/json and the "authorize" header to "Bearer [ your API token ]". Finally, use the body of the HTTP request to supply data to your import. The body structure should be an array of JSON objects. Each object in this array represents an individual record to be imported.↵Example body: [↵{ "id": 1, "name": "Joe" },↵{ "id": 2, "name": "Jim" }↵]"
"import.http._asyncHelperId": "Select an existing Async Helper configuration or create a new one to be used for async response processing."
"import.mapping.lists.fields.useFirstRow": ""
"import.mapping.lists.fields.useAsAnInitializeValue": "NetSuite allows certain fields to be initialized (pre-loaded on the NetSuite form) during create/transform of a record. Mark this check box if you would like to add this field during record initialization. ↵Example: If you are trying to create a non inventory item and you want to specify the subtype as "Sale" or "Purchase" or "ReSale", this mapping has to be set during the initialization itself. In such cases, we mark the subtype mapping as an initialization parameter."
"import.netsuite-edit-mapping": "Click this button to set or edit the mappings for the primary record that is being imported. This is where you will edit both header and line level mappings."
"import.mongodb.lookupType": "There are two ways to identify existing records. Either by testing for the existence of a field value on the export record (such as id), or by performing a lookup against the destination application. Choose the option, "Records have a specific field populated" if you can identify existing records by examining the content of your export records. If on the other hand a lookup is necessary, select the "Run a dynamic search against MongoDB" option. After making this selection, other fields will become available to describe how to define your lookup."
"import.netsuite-sub-record-config-button": "This button represents a subrecord that will be imported under the primary record type selected in the Record Type field. To change what subrecord type is imported or where the data is extracted from: click the down arrow and select Edit Configuration. To remove this subrecord import click the down arrow and select Remove."
"import.netsuite-record-config-button": "This button represents the primary record type you are importing. To change the record type shown on this button you need to change the value selected in the Record Type field. To add a subrecord to be mapped: click the down arrow and click Add Subrecord Import."
"import.netsuite.hooks.postMap": ""
"import.netsuite-subrecord-mapper": "Click this button to set or edit the mappings of this subrecord on your import. These mappings will be processed along with the primary record mappings, and the resulting record will be submitted at the same time."
"import.netsuite.hooks.preMap": ""
"import.netsuite.hooks.postSubmit": ""
"import.netsuite.lookups.failFields": "<b>Fail Record:</b> If no results are found or the dynamic lookup fails, the lookup will silently fail (return empty string). Similarly, if multiple results are found  (dynamic lookup) then the first value is chosen. In other words, if allowFailures is set to true, then no errors will be raised and the default lookup value will be used if the lookup fails. ↵↵<b>Use Empty String as Default Value:</b> Please select this field if you want to use ‘’(i.e. the empty string) as the default lookup value. This value will be used if your lookup does not find anything. ↵↵<b>Use Null as Default Value:</b> Please select this field if you want to use ‘null’ as the default lookup value. This value will be used if your lookup does not find anything. ↵↵<b>Use Custom Default Value:</b> This holds the default value to be set for the extract field."
"import.netsuite.jsonPath": "Select the element of the data that contains the list of objects that will be used in mapping to the subrecords. If you are mapping to subrecord under a sublist (such as inventory detail on the item list of a transaction) you should select the node that contains the list of items."
"import.netsuiteImportFieldMappingLookupType": "Use a dynamic search if you need to lookup data directly in the import application, e.g. if you have an email address in your export data and you want to run a search on the fly to find a system id value in the import application. Use a static value to value mapping when you know in advance all the possible values and how they should be translated. For example, if you are mapping a handful of shipping methods between two applications you can define them here."
"import.netsuite.referenceField": "Select the NetSuite subrecord under the chosen record type that you want to import. For example if you want to select the inventory detail section of an item fulfillment select "Items : Inventory Details"."
"import.oneToMany": "There are advanced use cases where a parent record is being passed around in a flow, but you actually need to process child records contained within the parent record context. For example, if you're exporting Sales Order records out of NetSuite and importing them into Salesforce as Opportunity and Opportunity Line Item records, then you will need to import the Opportunity Line Item records using this option."
"import.netsuiteImportFieldMappingSettings": "The type of field mapping that you want to perform. For more information refer to, the <a href="https://celigosuccess.zendesk.com/hc/en-us/sections/205928707-Field-Mapping-options-in-integrator-io" target="_blank"/> Field Reference Guide.</a>"
"import.pathToMany": "If the parent record is represented by a JSON object then this field should be used to specify the JSON path of the child records. If the parent record is represented by a JSON array (where each entry in the array is a child record) then this field does not need to be set. If you are unsure how parent records are being represented in your flow then please view the 'Sample Data' field for the 'Export' resource that is generating the data. Following are two examples also to hopefully help clarify how data can be represented differently depending on the export context. Example 1: If you are exporting Sales Orders out of NetSuite in real-time then NetSuite sends integrator.io a JSON object for each Sales Order, and if you want to process the line items in that Sales Order then you need to specify the JSON path for the line items field. There is no way to tell NetSuite to send an array for real-time data. Example 2: But, if you are exporting Sales Orders out of NetSuite via a scheduled flow then in this case NetSuite represents each order via an array where each entry in the array represents a line item in the order. There is no way to tell NetSuite to give you an object for batch data."
"import.overrideDataURITemplate": "For applications like NetSuite and Salesforce, integrator.io will by default try to generate links for any records that fail to import and then display those links in your job dashboard.  If you prefer to define your own custom links then please use this handlebars field to override the default functionality.  Please note that the template you provide will run against your data after it has been mapped, and then again after it has been submitted to the import application, to maximize the ability to link to the right place.  For example, if you are importing sales orders but instead want the errors to link to customers, you could use the following.  "https://system.na1.netsuite.com/app/common/entity/custjob?id={{{entity}}}""
"import.rdbms.lookups.failFields": "<b>Fail Record:</b> If no results are found or the dynamic lookup fails, the lookup will silently fail (return empty string). Similarly, if multiple results are found  (dynamic lookup) then the first value is chosen. In other words, if allowFailures is set to true, then no errors will be raised and the default lookup value will be used if the lookup fails. ↵↵<b>Use Empty String as Default Value:</b> Please select this field if you want to use ‘’(i.e. the empty string) as the default lookup value. This value will be used if your lookup does not find anything. ↵↵<b>Use Null as Default Value:</b> Please select this field if you want to use ‘null’ as the default lookup value. This value will be used if your lookup does not find anything. ↵↵<b>Use Custom Default Value:</b> This holds the default value to be set for the extract field."
"import.rdbms.lookups.extract": "When integrator.io runs this lookup it will read the column named in this field from the SQL result set and return that single value as the result of the lookup. Please make sure this field contains a valid column name from your database table."
"import.rdbms.lookups.query": "The query that fetches records to be exported."
"import.rdbms.lookups.name": "Name of the lookups that will be exposed to the mapping to refer."
"import.rest.composite.create.body": "Click this button to specify Handlebar expression which will be evaluated and the result is used as Http Request body while importing."
"import.rdbms.type": "Please select 'Insert' if you are only importing new records into the Database. Please select 'Update' if you are only importing changes to existing records in the Database. Please select 'Insert or Update' if you want your import to be more dynamic such that (1) if an existing record exists in the Database then that record will be updated, or (2) if an existing record does not exist then a new record will be created."
"import.rest.composite.create.relativeURI": "The typical value of this field is the resource path portion of an API endpoint. Some examples are: '/product' or '/bulkUpdate/orders'. This relativeURI value is combined with the baseURI defined in the connection resource associated with this import. The baseURI and relativeURI together complete a fully qualified url that describes an API endpoint. Note that occasionally query string parameters can be used to pass extended information to an API endpoint."
"import.rest.composite.create.method": "Choose the HTTP method to use for requesting the endpoint. Most of the endpoints use POST method for creating new records. But some endpoints might be using PUT method for the same."
"import.rest.composite.create.successPath": "There are some APIs out there (i.e. Slack) that will return a 200 HTTP status code even if an HTTP request fails. These APIs instead use a field in the HTTP response body to identify success vs fail. For these APIs, this option field 'Success Path' can be used to specify the JSON path for the field in the response body that should be used to determine if an HTTP request was successful. For example, if you are working with Slack's API you would set this field to: 'ok'."
"import.rest.composite.create.responseIdPath": "This field is used to help integrator.io find the identifer (id) of the resource returned in the HTTP response. Use the complete path of the resource id within the response. If this field is left blank, integrator.io will try to find a property named id or _id anywhere in the response body."
"import.rest.composite.ignore.resourceId": "This field is used to inform integrator.io on how to identify existing records, and if a record is found to exist, it will be ignored (no operation performed for this record). integrator.io will determine if a record exists by the presence of a specific record property. Typically this would be a field that is only present on existing records such as an "ID", or "createDate". If this is the case, simply provide the field path to this property. Example: "customerId" or "dateCreated".Alternatively, identify existing records by using the result of a lookup. If the lookup returned a value, then this would be an indication that the record exists. An example of this would be a lookup that maps an email from the export record to an ID from the destination App. If this is how you wish to identify an existing lookup, first define the lookup and then simply enter the lookup's name in this field."
"import.rest.composite.create.successValues": "This field indicates the value(s) that represents the success of an HTTP response. For example, 0 or 0,2,3 . This field is used in unison with the Success Path field. The value found in the HTTP response at the path specified in Success Path is compared against the provided list of success values. If there is an exact case-sensitive match of any of the specified values, the request is considered successful."
"import.rest.composite.update.body": "Click this button to specify Handlebar expression which will be evaluated and the result is used as Http Request body while importing."
"import.rest.composite.type": "Choose 'Create New and Update Existing' to dynamically create vs update records in the import application based on their existence in that application already. Choose 'Create New Data and Ignore Existing Data' to only create new records, and this option will ignore records that exist already. Choose 'Update Existing Data and Ignore New Data' to only update existing records, and this option will ignore records that cannot be found.""
"import.rest.composite.update.relativeURI": "The typical value of this field is the resource path portion of an API endpoint. Some examples are: '/product' or '/bulkUpdate/orders'. This relativeURI value is combined with the baseURI defined in the connection resource associated with this import. The baseURI and relativeURI together complete a fully qualified url that describes an API endpoint. Note that occasionally query string parameters can be used to pass extended information to an API endpoint."
"import.rest.composite.update.method": "Choose the HTTP method to use for requesting the endpoint. Most of the endpoints use PUT method for updating existing records. But some endpoints might be using POST method for the same."
"import.rest.composite.update.successPath": "There are some APIs out there (i.e. Slack) that will return a 200 HTTP status code even if an HTTP request fails. These APIs instead use a field in the HTTP response body to identify success vs fail. For these APIs, this option field 'Success Path' can be used to specify the JSON path for the field in the response body that should be used to determine if an HTTP request was successful. For example, if you are working with Slack's API you would set this field to: 'ok'."
"import.rest.composite.update.responseIdPath": "This field is used to help integrator.io find the identifer (id) of the resource returned in the HTTP response. Use the complete path of the resource id within the response. If this field is left blank, integrator.io will try to find a property named id or _id anywhere in the response body."
"import.rest.lookups.failFields": "<b>Fail Record:</b> If no results are found or the dynamic lookup fails, the lookup will silently fail (return empty string). Similarly, if multiple results are found  (dynamic lookup) then the first value is chosen. In other words, if allowFailures is set to true, then no errors will be raised and the default lookup value will be used if the lookup fails. ↵↵<b>Use Empty String as Default Value:</b> Please select this field if you want to use ‘’(i.e. the empty string) as the default lookup value. This value will be used if your lookup does not find anything. ↵↵<b>Use Null as Default Value:</b> Please select this field if you want to use ‘null’ as the default lookup value. This value will be used if your lookup does not find anything. ↵↵<b>Use Custom Default Value:</b> This holds the default value to be set for the extract field."
"import.rest.composite.update.successValues": "This field indicates the value(s) that represents the success of an HTTP response. For example, 0 or 0,2,3 . This field is used in unison with the Success Path field. The value found in the HTTP response at the path specified in Success Path is compared against the provided list of success values. If there is an exact case-sensitive match of any of the specified values, the request is considered successful."
"import.rest.lookups.useNull": "Please check this field if you want to use 'null' as the default lookup value. This value will be used if your lookup does not find anything."
"import.rest.lookups.useEmptyString": "Please check this field if you want to use '' (i.e. the empty string) as the default lookup value. This value will be used if your lookup does not find anything."
"import.restImportFieldMappingSettings": "The type of field mapping that you want to perform. For more information refer to, the <a href="https://celigosuccess.zendesk.com/hc/en-us/sections/205928707-Field-Mapping-options-in-integrator-io" target="_blank"/> Field Reference Guide.</a>"
"import.restImportFieldMappingLookupType": "Use a dynamic search if you need to lookup data directly in the import application, e.g. if you have an email address in your export data and you want to run a search on the fly to find a system id value in the import application. Use a static value to value mapping when you know in advance all the possible values and how they should be translated. For example, if you are mapping a handful of shipping methods between two applications you can define them here."
"import.salesforce.lookups.failFields": "<b>Fail Record:</b> If no results are found or the dynamic lookup fails, the lookup will silently fail (return empty string). Similarly, if multiple results are found  (dynamic lookup) then the first value is chosen. In other words, if allowFailures is set to true, then no errors will be raised and the default lookup value will be used if the lookup fails. ↵↵<b>Use Empty String as Default Value:</b> Please select this field if you want to use ‘’(i.e. the empty string) as the default lookup value. This value will be used if your lookup does not find anything. ↵↵<b>Use Null as Default Value:</b> Please select this field if you want to use ‘null’ as the default lookup value. This value will be used if your lookup does not find anything. ↵↵<b>Use Custom Default Value:</b> This holds the default value to be set for the extract field."
"import.salesforce.api": "Salesforce supports both SOAP and REST API types.  Salesforce actually supports a multitude of different API types, but SOAP and REST are the most relevant for importing data via integrator.io.  SOAP is recommended here because SOAP supports the ability to submit more than one record at a time (i.e. in a single API request).  Salesforce governs its API based on the total number of API requests per day, so it is important to batch up your data wherever possible; and with the REST API you are limited to only one record per API request.  The REST API can be a slightly better option when the data being imported is guaranteed to come in one record at a time, or if you are using the integrator.io API to invoke the import from your own application and you prefer the REST paradigm."
"me.change-email": "Email is a very important field. Password reset links, product notifications, subscription notifications, etc. are all sent via email. It is highly recommended that you take the time to secure your email, especially if you are integrating sensitive information with your integrator.io account."
"jobErrors.helpSummary": "This page allows you to manage all the errors associated with a specific integration job. In general, the best practice for fixing errors is always to understand the root cause for each error, and then to fix the root problem so that the same type error does not repeat again. For example, if you get an error that a record was rejected because a required field was missing then you should first try to make the same field required in all the applications being integrated, or if this is not possible then you should enhance your field mapping for that field so that a default value is auto set when a value is missing.↵↵The 'Retry' button can be used to process one or more records again. For example, if several records were rejected because an application was experiencing network issues, then you can click 'Retry All' to quickly rerun all the records again.↵↵The 'Mark Resolved' button can be used to clear one or more errors when there is no need to reprocess the records again. For example, if a record was rejected because it already exists in the import application then there is no need to submit it again.↵↵If your integration job contains more than 1000 errors then you need to click the 'Download All Errors' button to view and manage the errors in a CSV file. The CSV error file that you download will have specific columns to retry errors, or to mark them as resolved. After you process all the errors in the CSV error file, then you need to click the 'Upload Processed Errors' button to submit the processed file. The result of submitting the CSV error file is exactly the same as processing errors directly on the dialog when the number of errors is less than 1000. VERY IMPORTANT THOUGH, if you are uploading a processed error file, the uploaded file will completely replace the error file currently associated with the job, and if you remove entries from the CSV error file then they will also be removed from the job. Saying this another way, even if you are only fixing a couple of errors it is very important that you always submit the entire file to avoid losing any error data.↵↵The 'Source' column indicates the source of the error. For example, if the Salesforce API rejects your data due to an invalid phone field, then the 'Source' of that error would be 'salesforce'. Another example, if you are doing a dynamic lookup in one of your Salesforce field mappings, but the record being looked up cannot be found by integrator.io, then that error would have source 'adaptor'.↵↵The 'Code' column indicates the code of the error. For example, if you are submitting data to a REST API you might see the value 422, which is the generic HTTP response code indicating that there was an error in the data. Another example, if you are submitting data to NetSuite you might see 'invalid_fld_value', which is NetSuite's generic code that you sent invalid data for a specific field.↵↵The 'Message' column represents the full error message. Please note that many APIs do not have great error messages, and the values reported in this column can be difficult to process.↵↵The 'Retry Data' column will have an edit icon displayed when there is retry data associated with the error. You can use this icon to quickly fix and resubmit failed data. For example, you might have a web order that is stuck processing because it contains an invalid phone number, and you can use this edit icon to fix the phone field immediately (or remove it) to get your order processed asap."
"me.dateFormat": "Use this field to configure how you want dates to be formatted in your integrator.io account. For example, there is a dashboard in your integrator.io account to view integration activity, and this field controls how the dates on that page appear."
"me.change-password": "There are minimum password requirements that all integrator.io users must satisfy, but we highly recommend using a password management app to auto generate a truly random, complex password that no one can remember or guess, and then rely solely on your password management app to sign you in to integrator.io."
"me.google-header": "Click here to enable 'Sign in via Google'. Once this setting is enabled you will no longer need to enter email and password to sign in to integrator.io. This setting can be disabled and/or changed at any time."
"me.google-email": "This is the Google email linked to your integrator.io account."
"me.google-link": "Click here to enable 'Sign in via Google'. Once this setting is enabled you will no longer need to enter email and password to sign in to integrator.io. This setting can be disabled and/or changed at any time."
"me.google-id": "This is the Google Id linked to your integrator.io account."
"me.timeFormat": "Use this field to configure how you want times to be formatted in your integrator.io account. For example, there is an Audit Log page in your integrator.io account that lists changes made to resources in your account, and this field controls how the times on that page appear."
"me.google-unlink": "Click here to disable 'Sign in via Google'. Once this setting is disabled the only way to access your integrator.io account is via email and password."
"notifications.jobErrors": "Please choose 'All Flows' to receive an email notification whenever any flow in this integration has a job error, or select individual flows to focus your email traffic to just higher priority data flows."
"notifications.connections": "Please select which connections you would like to be notified about when they go offline (and subsequently back online).  Please note that connections can be shared across integrations, and if you choose to be notified here, this notification setting will be reflected everywhere else this connection is being used."
};